---
title: "운영체제 7. 해킹을 어떻게 예방할까"
date: "2025-07-19 14:51:21"
categories: ["IT", "운영체제"]
tags: []
math: true
toc: true
comments: true
---

### 불법 메모리 접근, 불법 I/O, 악의적 무한 루프를 어떻게 보호하는가?
I/O의 권한을 프로세스에서 막 취득할 수 있으면 키보드 정보나 웹캠 등의 정보를 뽑아갈 수 있다. 메모리 주소도 함부로 접근할 수 있으면, 다른 프로세스에서 사용하는 메모리의 정보를 조작하여 치트 프로그램을 만들 수 있다. 혹은 고의적으로 무수히 많은 프로세스를 생성해서 무한 루프를 돌리면 컴퓨터를 순식간에 먹통으로 만들어버릴 수도 있다. **이를 어떻게 보호하는가?**

**(1) 불법 메모리, I/O 접근**
아이디어는 다음과 같다. 유저 모드와 커널 모드 `(듀얼 모드)`로 구분하고, 유저 모드에서 중요한 명령어를 실행하기 위해선 모두 트랩 명령어로 접근하도록 구현한다. 트랩 명령어란 커널에게 이거 해달라고 싹싹 부탁하는 명령어와 같다. CPU가 트랩 명령어를 받으면, 커널 모드로 변경 후 커널 내의 Interrupt Handler 함수를 실행하여 중요한 명령어를 실행한다. 이 중요한 명령어는 반드시 커널 모드일때만 실행 가능하다. 모드 비트는 CPU 내의 상태 레지스터에 들어있다. 모드 비트의 변경 또한 특권 명령어로만 바꿀 수 있다. 즉 유저 입장에선 인터페이스로 약속된 트랩 명령어를 실행하거나, 모드 비트를 강제로 바꾸는 수 밖에 없다. 모드 비트를 바꾸는 것은 오로지 CPU 하드웨어 수준에서 수행되기 때문에, 불가능에 가깝다. 

그러나 메모리에 읽고 쓰는 명령어는 특권 명령어가 아니다. 그러면 어떻게 보호하는가? 프로세스마다 어디서부터 어디까지 메모리를 사용할지 범위가 제한되어 있다. 프로세스가 특정 메모리 주소에 접근하려 하면, 회로 수준에서 이 범위를 체크해주는 하드웨어(MMU) 가 존재한다. 이 하드웨어 수준에서 컷 한다. 그 범위를 조절하는 명령어는 특권 명령어로 설정하여 함부로 조작하지 못한다.

> [!tip] MMU가 무엇인가?{title}
> CPU에서 Virtual Address를 사용하려면, 이를 실제 메모리 주소로 변환해야 한다. 어떻게 변환하는가? CPU 내의 **Memory Management Unit (MMU, 메모리 관리 장치)** 라는 하드웨어가 그 책임을 맡는다. CPU는 레지스터에 담긴 가상 주소를 MMU에게 넘기면, MMU는 가상 메모리 주소를 실제 메모리 주소로 바꿔준다. 이것이 어떻게 가능한가? MMU가 갖고있는 가상 주소와 실제 주소가 Mapping된 캐시 테이블 또는 메모리에 저장된 전체 테이블을 참조하여 실제 메모리 주소를 얻어낸다.

**(2) 악의적 무한 루프**
시분할 시스템에선 우선순위 조절을 통해 막을 수 있다. 무한루프를 돈다는 것은, 스케쥴링해줬는데 Time slice를 항상 다써버리는 CPU-Bound 작업과 같다. 이 괘씸한 작업은 우선순위를 계속 낮춘다. 무한 루프를 돌면, 우선순위가 계속 낮아져서 다른 모든 작업이 처리되고 나서야 무한 루프를 도는 프로세스가 수행될 것이다.

만약 악의적인 프로세스가 아니라 건전한 CPU-Bound 프로세스인데 우선순위가 계속 낮아져 평생 수행되지 못하면 어떻하냐? 따라서 우선순위가 아주 낮은 프로세스는 지하에 계속 처박아두지 않고, 우선순위를 쪼끔씩 올려준다. 이를 **에이징**이라고 부른다.