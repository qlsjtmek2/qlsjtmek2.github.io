---
title: "고급컴퓨터그래픽스 11. Vulkan"
date: "2024-11-29"
categories: ["IT", "고급컴퓨터그래픽스"]
tags: ["Vulkan", "Command Buffer", "Descriptor Set", "Command Pool", "Surface", "Swap Chain", "병렬 프로그래밍", "GPU"]
math: true
toc: true
comments: true
---

건국대학교 고급컴퓨터그래픽스 김형석 교수님의 수업을 정리한 내용입니다.

## Structure

![Pasted image 20241129091423.png](/assets/img/posts/Pasted image 20241129091423.png)

Vulkan을 사용하는 Application의 계층 구조는 위와 같다. Vulkan Library 사용자는 가장 먼저 Instance를 생성해야 한다. Instance를 통해 초기 환경설정을 셋팅한다. Instance는 현재 프로세스를 실행중인 Device의 GPU를 찾아 읽기 전용인 Physical Device 객체를 생성한다. Physical Device에 접근하여 GPU의 전용 속성을 확인할 수 있다. 이후 프로그래머는 Logical Device를 통해 GPU를 조작한다. Logical Device는 Physical Device에 의존하는 GPU를 조작하는 Interface라고 보면 된다. Logical Device를 통해 CPU, Memory <-> GPU로 데이터를 전송하는 Bus를 만들며, 큐의 내용으로 Command Buffer를 전송한다.

## Command, Command Buffer, Command Pool

Queue를 통해 GPU로 여러 Command를 전송할 수 있고, Command는 Command Buffer에 담아서 덩어리 단위로 전송한다. Command으로는 크게 그래픽 Command, 컴퓨팅 Command, 메모리 관리 Command가 존재한다.

Command Buffer는 Command Pool에 등록되어 메모리를 할당받는다. 마치 C에서 malloc으로 객체의 메모리 사이즈를 얼만큼 할당하고 언제 해제할 것인지 명시하듯, Vulkan에서는 메모리 관리가 프로그래의 책임이다. 따라서 Buffer 객체의 메모리를 할당받기 위해 Command Pool을 사용한다. Command Pool로 생성된 Command Buffer의 메모리는 Command Pool을 조작하여 일괄적으로 관리할 수 있게 된다. 

즉 프로그래머는 Command Pool를 통해 얼만큼 사이즈의 메모리를 가진 Command Buffer를 할당받는다. 이후 Command를 Command Buffer에 등록하고, 이 Command Buffer 단위를 Queue를 통해 GPU로 전송할 수 있다.

## Descriptor Set, Descriptor Pool

![Pasted image 20241129101902.png](/assets/img/posts/Pasted image 20241129101902.png)

DescriptorSet은 Shader에서 사용할 Uniform Resource들을 관리하는 하나의 단위이다. DescriptorPool을 만들고, Pool을 통해 DescriptorSet를 할당받을 수 있다. 이후 Texture 또는 int, float, vec3, mat4같은 Uniform 변수에 전달할 데이터를 Set에 등록한다. Texture가 아닌 정보(int, mat4 등..)는 하나씩 Set에 등록하는게 아니라, 하나의 Buffer로 묶어 DescriptorSet에 등록한다. 그 이유는, CPU<->GPU 사이의 통신은 무조건 Buffer 단위로 동작하기 때문이다. 

## Image, Sampler

Sampler는 Shader가 Image를 어떻게 읽어야 하는지 정보를 제공하는 객체다. 따라서 Image 하나만 넘기면 안되고, 반드시 Image와 같이 Sampler를 제공해야 한다. 즉 Shader에서 Texture를 입력받아 사용하고 싶다면 DescriptorSet을 할당받아 Image와 Sampler를 등록하고, Texture를 사용하고 싶은 Shader가 등록된 RenderPass 사용 전 DescriptorSet를 바인딩하면 Shader에서 Texture를 불러와 사용할 수 있다.


Render Pass, Pipeline, CPU memory와 GPU memory, Heap, Render 이후 생성된 Image는 GPU에서 바로 Display됨. 파일 저장등의 이유로 CPU로 가져와야할 땐 명령어를 사용함.

## Swap Chain

![Pasted image 20241129093732.png](/assets/img/posts/Pasted image 20241129093732.png)

Swap Chain이라는 Collection은 여러개의 Image Buffer를 갖는다. 이를 통해 Double Buffering, Triple Buffering, ... 등등의 Multiple Buffering을 구현할 수 있다. Double Buffering을 사용해서 Tearing 현상을 해결하려면, Image Buffer 개수를 2개를 만들고, 하나의 Image Buffer를 Display에 활성화 하고, 활성화되지 않은 Image Buffer는 초기화->Rendering를 수행하고 Rendering이 마치면 Image Buffer를 Swap한다. 이후 비활성화된 Buffer를 Clear하고 다시 Rendering를 수행하는 과정을 반복하여 Tearing 현상을 해결한다.

## Surface

API 사용자는 Instance 생성 후, Surface를 생성해야 한다. Surface는 API 사용자와 운영체제 Display System 사이의 Interface 역할을 한다. API 사용자는 Window 버전, Mac 버전, Android 버전을 따로따로 개발하는 것이 아니라, 그저 Surface를 사용하여 Display를 조작하면 된다. 그에 맞춰 Vulkan API 수준에서 운영체제에 맞게 알맞게 동작된다.

## How to Use?

1. Setup Instance
2. Setup Logical device
3. Setup Surfaces and swap chain
4. r
5. Setup Render passes
6. Graphics pipeline
7. Create Command Buffer
8. Start Main Loop!



분리를 통해 병렬 렌더링이 가능해짐. 배경 따로 캐릭터 따로 렌더링해서 렌더링 속도를 올릴 수 있음.

목적이 시험 문제가 될수있다

OpenGL에선 한 쓰레드에서 GPU로 데이터를 보내고있으면 다른 Thread는 데이터를 보내지 못하고 대기상태가 됨. Vulkan은 기다리는 과정 없이 쓰레드별로 독립적으로 수행 가능함.

메모리 카피 방식이 OPen GL과 Vulkan이 다르고 Vulkan 방식이 훨씬 빠르다?? OpenGL에선 GPU에서 CPU 메모리를 그냥 읽는방ㅅ기이고, Vulkan에선 메모리 큐를 통해서 메모리를 복사해서 Vram으로 가져온 후 GPU가 Vram에서 읽는다?? (정확힌 모름)

리테인보드 렌더링? defoward 렌더링? vulkan은 기본적으로 리테인보드 렌더링?


왜 CommandBuffer를 바로 만들게 하지 않고 CommandPool을 거쳐서 생성하도록 하는가? 왜냐하면, GPU마다 자원의 제약이 존재하기 때문이다. 메모리 공간의 제약에 따라 CommandBuffer를 5개밖에 못만들 수도 있고, 20개를 만들 수도 있다. 따라서 Pool에서 Physical Device의 조건들을 보고 자원을 관리해주는 중간 관리자 역할을 하는 것.

또, Command Pool은 Multi Thread에서 안전하다. 

Command LifeCycle에 중 Pending 상태일 때 딴짓이 가능함

CommandBuffer에는 두가지 Type이 존재한다. Primary Command Buffer, Secondary Command Buffer. Primary는 queue에 바로 넣을 수 있는 Command Buffer. Seconadry는 마치 함수와 같이 Command를 각각 다른 Thread에서 다른 방법으로 명령어를 재활용할 수 있게 해주는 버퍼다. 즉 Primary Command Buffer에는 보통 Secondary Command Buffer를 관리하는 Command만 들어가고 Singla Thread에서 작동하는 Command는 Secondray Command Buffer에 따로따로 저장해둔다.


OpenGL에선 Image Buffer를 2개밖에 못만듬. Vulkan에선 여러개, 백개도 만들 수 있음. 굳이 왜그래야하냐? 싶지만 이게 병렬 렌더패스때문이네. 렌더링 파이프라인을 3개를 만들어서 이미지들을 딱딱 만들어서 이미지 버퍼에 3개를 만들어두고 이미지를 차례로 뽑으면 이걸 잘 하면 이론상 3배 더 빠른 렌더링이 가능해질 수도 있음.

Vulkan에선 멀티성을 이용해서 각 쓰레드마다 플레이어 전용 쓰레드, 배경 전용 쓰레드, 유아이 전용 쓰레드에서 병렬적으로 돌려서 Command Buffer를 만들고 합쳐서 큐에 한번에전송함. 

병렬 프로세싱, 병렬 프로그래밍을 하는데 Mutex, 세마포어 등등을 통해 레이스 컨디션을 관리하는데, 이런건 쓰면 쓸수록 느려진다. 이론상 동기화가 필요 없는 병렬 프로그램이 제일 빠르지만, 적어도 한번은 어쩔수없이 해야하기 떄문에 각각을 독립적으로 실행하고 딱 한번 동기호하ㅏ는게 가장 빠르다. 벌칸ㄱ이 그거에 신경을 많이 썼다. 동기화를 최소화하고, 기능을 분리하여 병렬 프로그래밍의 속도를 잡고 마치 객체지향처럼 유연성이 있음

한번에 여러개의 모니터를 뿌려야할 수도 있는데 OpenGL에선 안되는데 Vulkan에선 큐를 여러개 사용하면 됨. 세마포아가 가장 좋지만 리소스를 많이먹고, 베리어블이 간단하지만 젤 느림. CPU GPU간의 연결을 봐야된다 하면 Fance